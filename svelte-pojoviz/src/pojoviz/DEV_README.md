# Development

## The algorithm

%PojoViz works in three phases:

### Configuration phase

An object hierarchy is represented in %PojoViz with the following properties:

- Entry point to the hierarchy (e.g. window.d3, window.THREE, window.document.head)
- Hierarchy *src* (if the hierarchy comes from an external resource that needs to be fetched on runtime)
- *forbidden objects* which are discarded when found by the DFS algorithm
- The maximum number of *levels* allowed while running the DFS algorithm

### Process phase

The process phase is done in demand and it does the following:

- fetch any required external resource (if *src* was set)
- forbid any existing object (configured through *forbiddenTokens*) from being inspected
- perform the analysis of all the objects added to the inspector (recursively)
  - checks if the current object is forbidden to discard it
  - if not then all the properties of the objects are retrieved with `Object.getOwnPropertyNames`
  - when a property is evaluated, e.g. `obj.property`
    - if it's non-accessible the property is discarded (e.g. function.caller, function.arguments)
    - if it's non-traversable the property is discarded (object are traversable properties)
  - the process above is run again for all the remaining objects until a recursion limit is reached
  (configured with *levels*) or all the objects in the hierarchy have been analyzed

### Render phase

The process phase above will store all the traversable objects in a `HashMap`, in the render phase:

- The traversable objects are stringified, what this means is that a simple object is returned for each
traversable object, each object has properties describing the value of the object (i.e. if a given property
is traversable, if it's a primitive value, etc)
- The edges connecting the objects are also stringified, each edge is represented a simple object
telling the source node, destination node and the property to get there, (e.g. `sourceNode[property] = destinationNode` )
- The stringified representation of the hierarchy is passed to the layout program (run by [Dagre](https://github.com/cpettitt/dagre))
which augments the info above with cartesian coordinates `(x, y)`, `width`, `height`
- The chosen renderer (d3 or three.js) renders the hierarchy representation created above

## Development notes

When the analysis of a hierarchy is done it's a must to have a data structure which stores the `visited`
state of an object, such a structure is implemented in ES6 as a [Map][Map], since that structure is only
available in modern browsers it was decided to implement a `HashMap` which uses a helper called `hashKey`
under the hood to set/get the unique hash of any object/primitive.

### hashKey

- %PojoViz's `hashKey` is a function that generates a unique hash of the argument that it receives and
it can be applied in both primitives and objects:
  - when it's applied to object `hashKey` defines an additional property whose key is `__pojovizKey__`
  created with the code below (which is done only once), whenever `hashKey` is called on the same object
  it'll get the stored hash from the object (identifying the uniqueness of an object)
  - when it's applied to primitives the value is just created and never saved on any structure

```javascript
// when applied on objects, hashKey adds the following property:
Object.defineProperty(obj, '__pojovizKey__', {
  // non-configurable
  // non-enumerable
  // non-writable
  value: value
});
```

`value` is determined as follows

```javascript
// uniqueId is an autogenerated increasing number starting from 1
value = typeof obj + '-' + uniqueId
```

Some examples:

```javascript
hashKey(Object) == 'function-1'
hashKey(Object.prototype) == 'object-2'
hashKey(42) == 'number-42'
hashKey('pojoviz') == 'string-pojoviz'
hashKey(undefined) == 'undefined-undefined'
hashKey(null) == 'object-null'

// since it was already generated, the value returned is the same one as the value stored on the Object
hashKey(Object) == 'function-1'
```

### HashMap

A `HashMap` is a simple object which stores objects and functions, the keys of the `HashMap` are the
strings generated by `hashKey`

some examples:

```javascript
var hm = new HasMap();
hm.put(Object);
hm.put(Object.prototype);

// hm contents:
{
  'function-1': Object,
  'object-2': Object.prototype
}
```

Instances of this class are used to determine the objects that were analyzed by an analyzer or
the objects that are forbidden under an analyzer

### labeler

The function `labeler` just like hashKeys saves a collection of labels that an object may have,
the labels are determined by the way an ancestor reaches an object or based on the `name` property
that a function may have, the collection is saved under `__pojovizLabel__`

some examples:
```javascript
// stores in an internal property in Object a possible label
labeler(Object)
Object.__pojovizLabel__ == [{
  from: null,
  label: Object
}]

// each object has the following structure
{
  from: the hashKey of the ancestor
  label: the property the current object is reached with from `from`, i.e. from[label] = object
}
```

An object might be reached from many ancestors thus it has many labels, to determine the best
label that suits the object a high priority determination algorithm is run which is basically as
follows:

- if the object is a constructor (a function with a name which is not empty), then the label
is equal to the object's name (e.g. for Object the label is `Object` since `Object.name === 'Object'`)
- if the object was reached through a property called `prototype` and the ancestor is a constructor
then the label is equal to the ancestors name plus the word prototype, e.g. when `Object.prototype`
is analyzed this algorithm determines that the ancestor `Object` was the one who reached this object
through the `prototype` property thus its label is `Object.prototype`
- in any other case the label is equal to the property this object was reached with, e.g. the function
`keys` which is a property of the function `Object` gets a label equal to `keys`

### ObjectAnalyzer

ObjectAnalyzer is the class that analyzes a given hierarchy, it's configured with the following info:

- `levels` which are the maximum number of levels that can be reached when an object is analyzed
- `visitSimpleFunctions` which is a flag used during the analysis to determine if simple functions
should be visited, this is done because of the excessive number of
nodes created for simple functions e.g. `Object.keys` would have its own node if `visitSimpleFunctions`
is set to true
- `visitArrays` just like simple functions, the number of nodes created for arrays might be huge
- `visitConstructors` which is a flag which acts as an override for functions that were discarded by
the previous flags, for the sake of the library a constructor is function
which passes the following test:

```javascript
utils.isConstructor = function (v) {
  return this.isFunction(v) && typeof v.name === 'string' &&
      v.name.length && v.name.search(/^[A-Z]/) > -1 &&
      v.prototype && v.prototype.constructor === v;
};
```

Some examples:

```javascript
var analyzer;

// analyzer created with the default values:
// see ObjectAnalyzer.DEFAULT_CONFIG
analyzer = new ObjectAnalyzer();

// `endless` analyzer
// configured to finish only when all the objects reachable by a source object
// are analyzed, creating nodes for arrays and simple functions
analyzer = new ObjectAnalyzer({
  levels: Infinity,
  visitConstructors: true,
  visitSimpleFunctions: true,
  visitArrays: true
});
```

Internally each instance of the `ObjectAnalyzer` class holds a `HashMap` for the objects analyzed,
a `HashMap` for some objects that are forbidden, after the instance was created we can configure
it with whatever objects we want to be avoided during the analysis:

```javascript
// forbidding the window object
analyzer.forbid([window]);

// forbidding 4 builtIn objects
analyzer.forbid([Object, Object.prototype, Function, Function.prototype]);
```

You'll see that forbidding the objects above is a common thing to do with all the `ObjectAnalyzer`
instances to avoid creating links from all the objects to `Object.prototype` and from all the functions
to `Function.prototype`, this is something we already know so that's why they're not shown when a
hierarchy is rendered to avoid the creation of many edges and nodes.

After the desired objects have been forbidden you can start the analysis of an objects with `add`:

```javascript
analyzer.add([document])
```

An elaborate example with the `Object` function:

```javascript
var analyzer = new ObjectAnalyzer();
analyzer.add([Object]);
```

```javascript
Object
 + length (number)
 ... many properties here
 + keys (function)
 +--> prototype (object, the Object's prototype)
 +--> [[Prototype]] (the hidden link to its prototype, which is
 					Function.prototype since Object is a function)

	Object.prototype
	 + toString (function, not a function constructor so it's not saved)
	 + constructor (function constructor but it's already saved)
	 ... many properties here

	Function.prototype (following the hidden [[Prototype]] link of the Object function)
	 + bind (function)
	 + toString (function)
	 ... many properties here
	 +--> constructor (function, the object Function)
	 + [[Prototype]] (points to Object.prototype but it's already saved)

	 	Function
	 	+ length (number)
	 	... many properties here
 		+ prototype (points to Function.prototype which is already saved)
 		+ [[Prototype]] (points to Function.prototype too)
```

After the analysis is done it's seen that 4 objects are discovered with this kind of analysis,
the objects are: `Object, Object.prototype, Function and Function.prototype`

Another example with the `Object` function but with `Function.prototype forbidden`:

```javascript
var analyzer = new ObjectAnalyzer();
analyzer.forbid([Object.prototype])
analyzer.add([Object]);
```

```javascript
Object
 + length (number)
 ... many properties here
 + keys (function)
 +--> prototype (object, the Object's prototype)
 +--> [[Prototype]] (the hidden link to its prototype, which is
 					Function.prototype since Object is a function, it's forbidden
 					and therefore it's not analyzed)

	Object.prototype
	 + toString (function, not a function constructor so it's not saved)
	 + constructor (function constructor but it's already saved)
	 ... many properties here
```

Forbidding `Function.prototype` made the analyzer to inspect only two objects (since `Function`
is only discovered through `Function.prototype`)

### Inspector

So basically the `ObjectAnalyzer` class requires some objects to forbid and some objects to add,
at any given doing this might not be possible because the object might not be reachable yet, let's
say we want to analyze a external hierarchy whose entry point is not available yet (but it will be
available when the external resource is fetched), this is where the `Inspector` class comes in.

The `Inspector` class has an `ObjectAnalyzer` instance and it's designed to do common operations
with the `ObjectAnalyzer` through simple instructions like forbidding a series of objects with a
simple string.

The Inspector class is configured with the following:

- `entryPoint` is a token which indicates an object to be analyzed in the future which can be reached
through the `window` object, e.g. to analyze a library like `Backbone` in the future the `entryPoint`
should be set to `Backbone`
- `src` is a pipe separated list of scripts that must be fetched before the `entryPoint` is analyzed
the tokens will be loaded in series
- `forbiddenTokens` is a pipe separated list of commands that tell the internal analyzer which objects
should be forbidden, to forbid the 4 objects seen above (`Object, Object.prototype, Function,
Function.prototype`) the command to forbid them all is `pojoviz:builtIn`, if also `window` needs to be
forbidden then the string should be `pojoviz:builtIn|pojoviz:window`, see the documentation
of the property for a deep explanation on how it works
- `alwaysDirty`, a hierarchy might be constantly changing, %PojoViz has an internal cache of these
inspector instances so once a hierarchy has been analyzed the next time it's analyzed it won't be
processed again but gathered from the cache
- `analyzerConfig` configuration passed to the `ObjectAnalyzer` instance this inspector has

Some examples:

```javascript
var inspector;

// inspector created with the default config, see Inspector.DEFAULT_CONFIG
inspector = new Inspector();

// an inspector for the Backbone library
// note how lodash will be loaded before backbone
inspector = new Inspector({
  src: '//cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.js|//cdnjs.cloudflare.com/ajax/libs/backbone.js/1.1.2/backbone.js',
  entryPoint: 'Backbone'
});

// a complex inspector which has configuration for an `endless` analyzer
inspector = new Inspector({
  alwaysDirty: true,
  src: '//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js|//cdnjs.cloudflare.com/ajax/libs/handlebars.js/1.1.2/handlebars.js|//cdnjs.cloudflare.com/ajax/libs/ember.js/1.6.1/ember.js',
  entryPoint: 'Ember',
  forbiddenTokens: 'global:$|global:Handlebars|pojoviz:builtIn|pojoviz:window|global:document',
  analyzerConfig: {
    levels: Infinity,
    visitConstructors: true,
    visitSimpleFunctions: true,
    visitArrays: true
  }
})
```

The inspector instance will load all it requires on demand, that means that even though the instances
are created the analysis phase hasn't been triggered yet, to trigger the analysis execute `.init`
which returns a promise whose resolution value is the inspector itself

```javascript
var inspector = new Inspector({
  src: '//cdnjs.cloudflare.com/ajax/libs/lodash.js/2.4.1/lodash.js|//cdnjs.cloudflare.com/ajax/libs/backbone.js/1.1.2/backbone.js',
  entryPoint: 'Backbone'
});

inspector
  .init()
  .then(function (inspector) {
    // do whatever you want with the inspector or with analyzer here
    // e.g. stringify the nodes/edges stored in the analyzer
    inspector.analyzer.stringify()
  })
```

#### init

Running `init` on an existing inspector will do the following operations by default:

- fetch any external resources
- marks the internal analyzer as `dirty` if `alwaysDirty` is set to true on the Inspector,
what dirty means is that the analyzer will redo the same analysis even if there's something cached
- makes the inspection (forbidding the objects stored in `forbiddenTokens` and analyzing the
`entryPoint` object)

### pojoviz

%PojoViz has a useful method to create an inspector running `init` immediately on it, that method is
called `run`:

```javascript
var configuration = { ... }

// creating an analyzer based on an existing configuration
var analyzer = new Analyzer(configuration);
analyzer
  .init()
  .then(function (inspector) { });

// the same operation above can be shortened to
pojoviz
  .run(configuration)
  .then(function (inspector) { });
```

Executing `run` has some advantages like saving the instance created in cache (so that further calls
with the same configuration use the already created inspector)

### Rendering inspectors

The `pojoviz.draw` package contains methods to render existing `Inspector` instances, there are two
renderers bundled, these are `d3` renderer and the `THREE` renderer, let's use the `d3` renderer in
the examples below.

First set an element to which render the graph:
```javascript
// there's a dom element whose id is canvas in the webpage
pojoviz.draw.getRenderer('d3').setCanvasEl('#canvas');
```

Next when the inspector is ready to be inspected run:

```javascript
var configuration = { ... }

pojoviz
  .run(configuration)
  .then(function (inspector) {
    pojoviz.draw.render(inspector);
  })
  .done();
```

`pojoviz.draw.render` does the following operations with the inspector:

- clear any existing graph rendered on the canvas
- process the inspector
 - gets a JSON of the internal analyzer the inspector has through `inspector.analyzer.stringify()`
 - determines the width/height of the node based on the labels to be shown
 - creates a layout of the graph through (`dagre`)
- the resulting layout along the nodes and edges are rendered with the selected renderer

-----

## Installation

with npm:
```javascript
npm install pojoviz --save-dev
```

with bower:
```javascript
bower install pojoviz
```

## Usage

node/iojs:
```javascript
var pojoviz = require('pojoviz');
```

In the browser:
```html
<!-- styles for the nodes rendered with d3 -->
<link rel="stylesheet" href="public/bower_components/pojoviz/public/css/pojoviz.css"/>

<script src="public/bower_components/pojoviz/build/pojoviz-vendor.js"></script>
<script src="public/bower_components/pojoviz/build/pojoviz.js"></script>
<script src="public/bower_components/pojoviz/build/pojoviz-renderers.js"></script>
```

_**It's recommended that you read the development notes to understand what's
happening under the hood**_

### hello world

Let's create a simple object reached with `window.hello`, to render the object we need to
tell %PojoViz the `entryPoint` to this object which is just `hello` (remember that the entry
point is a path followed from the `window` object)

<pojoviz-readme url="/examples/helloWorld.js" script></pojoviz-readme>

After looking at the demo many questions arise:

- **why is it labeled as `object-23`?**
 - remember that under the hood the `hashKey` class sets a unique identifier on the object and
 the `labeler` class gives it a name, `labeler` couldn't identify a name for the object and that's
 why the label is equal to `hashKey(window.hello)`, but it should be `object-1` right? well %PojoViz
 actually forbade some objects for you (see [this][Inspector default config]) and in the process the
 hashKey of those objects were also computed

- **I see that `aFunction` doesn't have its node, why is that?**
 - Since the analyzer by default doesn't analyze simple objects a node wasn't created for this node

- **What are those dots?**
 - The blue and red dots only appear for rendering purposes, a <span style="color: red">red</span> dot
 represents a function and a <span style="color: blue">blue</span> dot represents an object

- **I know that the hidden [[Prototype]] property of a simple object points to `Object.prototype` but I
can't see it, why is that?**
 - %PojoViz default constructor for the analyzer actually forbade all the builtIn objects (more on this
 later)

Let's render the same object without forbidding any object from being analyzed, to do that
pass the option `forbiddenTokens: ''` to the Inspector constructor or to the `run` method of %PojoViz

<pojoviz-readme url="/examples/helloWorldNoForbid.js" script></pojoviz-readme>

Now you see that the label has changed to `object-1` since no object was analyzed/forbidden before,
also we can see the `Object.prototype` node is now visible

Let's make some experiments, how about forbidding the `Function` function? that way only three
objects will be shown: `hello, Object` and `Object.prototype`, the way to forbid objects is through
a command in the form `command:object`, all the builtIn objects are saved by convenience in the
command `pojoviz:builtIn`. To forbid an object reached from window enter `global:path.to.object`
also multiple commands can be separated with the pipe symbol e.g. `pojoviz:builtIn|global:document`
so for the example above the command needs to be `global:Function|global:Function.prototype`

<pojoviz-readme url="/examples/helloWorldForbidFunction.js" script></pojoviz-readme>

What if we make %PojoViz render itself?

<pojoviz-readme url="/examples/pojoviz.js" script></pojoviz-readme>

Whoa too much stuff, let's mess with the analyzer to avoid the creation of some nodes, we saw strange
stuff like nodes with numbers and a node with numbers gives us the hint that it might be an `Array`,
how about trying to avoid rendering arrays? to do so pass `visitArrays: false` to the `analyzerConfig`
constructor.

The object `analyzerConfig` is passed as a configuration option to the `analyzer` constructor,
the options available are shown above in the development notes.

<pojoviz-readme url="/examples/pojovizNoArrays.js" script></pojoviz-readme>

Still too many nodes, let's limit the number of levels to `0` (only the %PojoViz object will be
analyzed), try changing the number of levels to experiment

<pojoviz-readme url="/examples/pojovizLevels.js" script></pojoviz-readme>

Let's go back to a simpler example, how about rendering a constructor:

<pojoviz-readme url="/examples/simple.js" script></pojoviz-readme>

As seen the constructor nor its prototype were rendered, %PojoViz will only analyze functions
whose name starts with an uppercase letter, why? this assumption was done to limit the number of nodes
created (otherwise any function would be a constructor)

Let's solve this problem by making the name of the constructor uppercase:

<pojoviz-readme url="/examples/simpleUppercase.js" script></pojoviz-readme>

Now that works, but what if we can't change the code? we need to force %PojoViz to analye all
kind of functions, to do so pass `visitSimpleFunctions: true` in the `analyzerConfig` object,
<span style="font-size: 20px; color: rgb(179, 171, 12);">be warned though, a lot of nodes will be created
in a complex structure</span>

<pojoviz-readme url="/examples/simpleForceVisit.js" script></pojoviz-readme>

What if the things to analyze are not available yet? this is the case of the libraries and frameworks
rendered in this app, to indicate %PojoViz that we need to fetch an external resource let's
use the `src` configuration, how about rendering [Katex](http://khan.github.io/KaTeX/)

<pojoviz-readme url="/examples/external.js" script></pojoviz-readme>

Let's render `EmberJS`, kinda complex configuration (hold on a little bit while the resources
are fetched):

<pojoviz-readme url="/examples/externalEmber.js" script></pojoviz-readme>

### Custom inspectors

`pojoviz.run` can create inspector instances with little code, but how about complex structures that
don't have an entry point but multiple entry points? in this case we must create our own
inspector. Let's imagine that we want to render many builtIn objects.

```javascript
// Objects to render:
Object, Function,
Array, Date, Boolean, Number, Math, String, RegExp, JSON, Error
```

After inheriting from `Inspector` we have to either use the hooks called from `Inspector.prototype.inspectSelf`
or override the method above:

<pojoviz-readme url="/examples/custom.js" script></pojoviz-readme>

### Known configurations

All the hierarchies shown on the application are saved inside `/src/hierarchies/`, feel free to fork the
project and add the configurations you want :)

[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
[Inspector default config]: https://github.com/maurizzzio/PojoViz/blob/master/src/analyzer/Inspector.js#L176-L180